{"name":"Clauth","body":"# clauth - OAuth 2 based simple authentication system for Clojure Ring\r\n\r\n[![Build Status](https://secure.travis-ci.org/pelle/clauth.png)](http://travis-ci.org/pelle/clauth)\r\n\r\nThis is a simple OAuth 2 provider that is designed to be used as a primary authentication provider for a Clojure Ring app.\r\n\r\nIt currently handles OAuth2 bearer authentication and interactive authentication. \r\n\r\nSee [draft-ietf-oauth-v2-bearer](http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-08)\r\n\r\nThe following bearer tokens are implemented:\r\n\r\n* [Authorization header](http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-08#section-2.1)\r\n* [Form encoded body parameter](http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-08#section-2.2)\r\n* [URI query field](http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-08#section-2.3)\r\n* Non standard http cookie ('access_token') for use in interactive applications\r\n* Non standard session ('access_token') for use in interactive applications\r\n\r\n## Install\r\n\r\nAdd the following dependency to your `project.clj` file:\r\n\r\n```clojure\r\n[clauth \"1.0.0-rc6\"]\r\n```\r\n\r\n## Usage\r\n\r\nThere are currently 2 middlewares defined:\r\n\r\n* wrap-bearer-token\r\n* require-bearer-token!\r\n\r\nBoth of them take as a parameter a function which should return a object representing the token. This could be a user object, but could also be a token object with specific meta-data. I may standardize on something when more of the framework is developed.\r\n\r\nThe object returned by your function is set to :access-token entry in the request.\r\n\r\nThe difference between wrap-bearer-token and require-bearer-token! is that wrap will find a token but not require it. require-bearer-token will return a [HTTP 401 header](http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-08#section-2.4).\r\n\r\n## Grant Types\r\n\r\nCurrently the following Grant types are supported:\r\n\r\n* [Authorization Code Grant](http://tools.ietf.org/html/draft-ietf-oauth-v2-25#section-4.1)\r\n* [Client Credential Grant](http://tools.ietf.org/html/draft-ietf-oauth-v2-25#section-4.4)\r\n* [Resource Owner Password Credential Grant](http://tools.ietf.org/html/draft-ietf-oauth-v2-25#section-4.3)\r\n\r\nGrant types are implemented using multimethods. To implement one \r\n\r\n```clojure\r\n(defmethod token-request-handler \"my_grant_type\" [req authenticator] ...)\r\n```\r\n\r\n## Authorization request\r\n\r\nWe currently support the following authorization requests:\r\n\r\n* [Authorization Code Grant](http://tools.ietf.org/html/draft-ietf-oauth-v2-25#section-4.1)\r\n* [Implicit Grant](http://tools.ietf.org/html/draft-ietf-oauth-v2-25#section-4.2)\r\n\r\n## Tokens\r\n\r\nThere is a protocol defined called Expirable which implements one function:\r\n\r\n```clojure\r\n(is-valid? token)\r\n```\r\n\r\nThis is implementend by IPersistentMap so {} represents a valid token where {:expires (date-time 2011)} is invalid.\r\n\r\nA OAuthToken record exists which can be instantiated and stored easily by the create-token function:\r\n\r\n```clojure\r\n(create-token client user)\r\n```\r\n\r\n## Client Applications\r\n\r\nA ClientApplication record exists which can be instantiated and stored easily by the register-app function:\r\n\r\n```clojure\r\n(register-app name url)\r\n```\r\n\r\nA client application has a client-id and a client-secret which is used for issuing tokens.\r\n\r\n## Users\r\n\r\nA User record exists which can be instantiated and stored easily by the register-user function:\r\n\r\n```clojure\r\n(register-user login password name url)\r\n```\r\n\r\n## Stores\r\n\r\nStores are used to store tokens and will be used to store clients and users as well.\r\n\r\nThere is a generalized protocol called Store and currently a simple memory implementation used for it.\r\n\r\nIt should be pretty simple to implement this Store with redis, sql, datomic or what have you. \r\n\r\nIt includes a simple Redis implementation.\r\n\r\nThe stores used by the various parts are defined in an atom for each type. reset! each of them with your own implementation.\r\n\r\nThe following stores are currently defined:\r\n\r\n* token-store is in clauth.token/token-store\r\n* auth-code-store is in clauth.auth-code/auth-code-store\r\n* client-store is in clauth.client/client-store\r\n* user-store is in clauth.user/user-store\r\n\r\nTo use the redis store add the following to your code:\r\n\r\n```clojure\r\n(reset! token-store (create-redis-store \"tokens\"))\r\n(reset! auth-code-store (create-redis-store \"auth-codes\"))\r\n(reset! client-store (create-redis-store \"clients\"))\r\n(reset! user-store (create-redis-store \"users\"))\r\n```\r\n\r\nAnd wrap your handler with a redis connection middleware similar to this: \r\n\r\n```clojure\r\n(defn wrap-redis-store [app]\r\n  (fn [req]\r\n    (redis/with-server\r\n     {:host \"127.0.0.1\"\r\n      :port 6379\r\n      :db 14\r\n     }\r\n     (app req))))\r\n```\r\n\r\n## Authorization OAuth Tokens\r\n\r\nThere is currently a single authorization-handler that handles authorization called authorization-handler. Install it in your routes by convention at \"/authorize\" or \"/oauth/authorize\". \r\n\r\n```clojure\r\n(defn routes [req]\r\n  (case (req :uri)\r\n    \"/authorize\" ((authorization-handler) req )\r\n    ((require-bearer-token! handler) req)))\r\n```\r\n\r\nAuthorization handler comes with defaults that use the various built in token, user etc. stores. You can override these by passing in a configuration map containing functions.\r\n\r\n```clojure\r\n(authorization-handler {:authorization-form authorization-form-handler\r\n                        :client-lookup clauth.client/fetch-client\r\n                        :token-lookup clauth.token/fetch-token\r\n                        :token-creator clauth.token/create-token \r\n                        :auth-code-creator clauth.auth-code/create-auth-code})\r\n```\r\n\r\n## Issuing OAuth Tokens\r\n\r\nThere is currently a single token-handler that provides token issuance called token-handler. Install it in your routes by convention at \"/token\" or \"/oauth/token\". \r\n\r\n```clojure\r\n(defn routes [req]\r\n  (case (req :uri)\r\n    \"/token\" ((token-handler) req )\r\n    ((require-bearer-token! handler) req)))\r\n```\r\n\r\nToken handler comes with defaults that use the various built in token, user etc. stores. You can override these by passing in a configuration map containing functions.\r\n\r\n```clojure\r\n(token-handler {:client-authenticator clauth.client/authenticate-client \r\n                :user-authenticator clauth.user/authenticate-user\r\n                :token-creator clauth.token/create-token\r\n                :auth-code-revoker clauth.auth-code/revoke-auth-code! \r\n                :auth-code-lookup clauth.auth-code/fetch-auth-code })\r\n```\r\n\r\n## Using as primary user authentication on server\r\n\r\nOne of the ideas of this is using OAuth tokens together with traditional sessions based authentication providing the benefits of both. To do this we create a new token when a user logs in and adds it to the session.\r\n\r\nWhy is this a good idea?\r\n\r\n* You will be able to view a list of other sessions going on for security purposes\r\n* You will be able to remotely log of another session\r\n* Your app deals with tokens only. So this is also ideal for an API with a javascript front end\r\n\r\nTo use this make sure to wrap the session middleware. We have a login handler endpoint that could be used like this:\r\n\r\n```clojure\r\n(defn routes [master-client]\r\n  (fn [req]\r\n  (case (req :uri)\r\n    \"/login\" ((login-handler master-client) req )\r\n    ((require-bearer-token! handler) req))))\r\n```\r\n\r\nThe master-client is a client record representing your own application. A default login view is defined in clauth.views/login-form-handler but you can add your own. This just needs to be a ring handler presenting a form with the parameters \"username\" and \"password\".\r\n\r\n```clojure\r\n(defn routes [master-client]\r\n  (fn [req]\r\n  (case (req :uri)\r\n    \"/login\" ((login-handler my-own-login-form-handler master-client) req )\r\n    ((require-bearer-token! handler) req))))\r\n```\r\n\r\n## Run Demo App\r\n\r\nA mini server demo is available. It creates a client for you and prints out instructions on how to issue tokens with curl.\r\n\r\n```\r\nlein run -m clauth.demo\r\n```\r\n\r\n## TODO\r\n\r\nThe goal is to implement the full [OAuth2 spec](http://tools.ietf.org/html/draft-ietf-oauth-v2-25). The only main feature missing is. I'll aim for that for 1.1 as most people currently don't use refresh tokens:\r\n\r\n* [Refresh Tokens](http://tools.ietf.org/html/draft-ietf-oauth-v2-25#section-1.5)\r\n\r\n## Contribute\r\n\r\nYou will need to have a Redis database running in the background in order to have some of the tests pass, otherwise, you will get an error about the connection being refused.\r\n\r\nIf you have Homebrew on Mac OSX, you can get Redis by typing ```brew install redis``` in the command line. Once that's done, get the Redis database started in your Terminal window by typing the following:\r\n\r\n```\r\nredis-server /usr/local/etc/redis.conf\r\n```\r\n\r\n## License\r\n\r\nCopyright (C) 2012 Pelle Braendgaard http://stakeventures.com\r\n\r\nDistributed under the Eclipse Public License, the same as Clojure.\r\n","tagline":"Authentication library for Clojure and Compojure","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}